{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Planned vs Reactive Experiment Results\"\n",
        "format:\n",
        "  html:\n",
        "    code-fold: true\n",
        "    page-layout: custom\n",
        "jupyter: python3\n",
        "---"
      ],
      "id": "4baa22f8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import json\n",
        "import glob\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "import plotly.graph_objects as go\n",
        "from plotly.subplots import make_subplots\n",
        "\n",
        "def process_json_files(file_pattern='*.json'):\n",
        "    \"\"\"\n",
        "    Process multiple JSON files and combine their data into a DataFrame.\n",
        "    \"\"\"\n",
        "    all_error_data = []\n",
        "    all_reactive_data = []\n",
        "    false_positives_data = []\n",
        "    \n",
        "    for filename in glob.glob(file_pattern):\n",
        "        try:\n",
        "            with open(filename, 'r') as f:\n",
        "                # Read the file content\n",
        "                file_content = f.read()\n",
        "                \n",
        "                # Split the content into separate JSON objects\n",
        "                json_objects = []\n",
        "                current_json = \"\"\n",
        "                depth = 0\n",
        "                \n",
        "                for char in file_content:\n",
        "                    current_json += char\n",
        "                    if char == '{':\n",
        "                        depth += 1\n",
        "                    elif char == '}':\n",
        "                        depth -= 1\n",
        "                        if depth == 0 and current_json.strip():\n",
        "                            try:\n",
        "                                json_obj = json.loads(current_json.strip())\n",
        "                                json_objects.append(json_obj)\n",
        "                                current_json = \"\"\n",
        "                            except json.JSONDecodeError:\n",
        "                                pass\n",
        "                \n",
        "                # Process the main data object\n",
        "                main_data = next((obj for obj in json_objects if 'results' in obj), None)\n",
        "                if main_data:\n",
        "                    # Extract user info\n",
        "                    user_info = main_data.get('userinfo', {})\n",
        "                    user_id = user_info.get('id', 'unknown')\n",
        "                    \n",
        "                    # Handle reactive results if present\n",
        "                    if 'reactive_results' in main_data:\n",
        "                        reactive_row = {\n",
        "                            'filename': filename,\n",
        "                            'user_id': user_id,\n",
        "                            **main_data.get('reactive_results', {}).get('ObjectsMissed', {})\n",
        "                        }\n",
        "                        all_reactive_data.append(reactive_row)\n",
        "                    \n",
        "                    # Process main results\n",
        "                    results = main_data.get('results', {})\n",
        "                    for error_type, error_data in results.items():\n",
        "                        for instance_num, instance_data in error_data.items():\n",
        "                            row = {\n",
        "                                'error_type': error_type,\n",
        "                                'instance': int(instance_num),\n",
        "                                'missed': instance_data['missed'],\n",
        "                                'time': instance_data['time'],\n",
        "                                'filename': filename,\n",
        "                                'user_id': user_id\n",
        "                            }\n",
        "                            all_error_data.append(row)\n",
        "                \n",
        "                # Process false positives data\n",
        "                fp_obj = next((obj for obj in json_objects if 'FalsePositives' in obj), None)\n",
        "                if fp_obj:\n",
        "                    fp_data = fp_obj.get('FalsePositives', {}).get('FalsePositives', {})\n",
        "                    for error_type, count in fp_data.items():\n",
        "                        false_positives_data.append({\n",
        "                            'error_type': error_type,\n",
        "                            'count': count,\n",
        "                            'filename': filename,\n",
        "                            'user_id': user_id\n",
        "                        })\n",
        "\n",
        "        except Exception as e:\n",
        "            print(f\"Error processing file {filename}: {e}\")\n",
        "            continue\n",
        "\n",
        "    # Create DataFrames with default columns even if empty\n",
        "    error_df = pd.DataFrame(all_error_data) if all_error_data else pd.DataFrame(\n",
        "        columns=['error_type', 'instance', 'missed', 'time', 'filename', 'user_id'])\n",
        "    reactive_df = pd.DataFrame(all_reactive_data) if all_reactive_data else pd.DataFrame(\n",
        "        columns=['filename', 'user_id', 'rows', 'structures'])\n",
        "    false_positives_df = pd.DataFrame(false_positives_data) if false_positives_data else pd.DataFrame(\n",
        "        columns=['error_type', 'count', 'filename', 'user_id'])\n",
        "    \n",
        "    return error_df, reactive_df, false_positives_df\n",
        "\n",
        "\n",
        "def create_interactive_visualization(error_df, false_positives_df, type):\n",
        "    \"\"\"\n",
        "    Create interactive Plotly visualization with stacked bar plots for each error type.\n",
        "    \"\"\"\n",
        "    error_types = ['CameraError', 'FlightError', 'HardwareError']\n",
        "    users = sorted(error_df['user_id'].unique())\n",
        "    colors = {'caught': 'lightgreen', 'missed': 'lightcoral', 'false_positives': 'lightskyblue'}\n",
        "    \n",
        "    # Create subplots with consistent width\n",
        "    fig = make_subplots(\n",
        "        rows=1, \n",
        "        cols=3, \n",
        "        subplot_titles=error_types,\n",
        "        horizontal_spacing=0.1\n",
        "    )\n",
        "    \n",
        "    # Keep track of trace indices\n",
        "    total_traces = []\n",
        "    user_traces = []\n",
        "    \n",
        "    # Create base traces (aggregated view)\n",
        "    for i, error_type in enumerate(error_types, 1):\n",
        "        error_data = error_df[error_df['error_type'] == error_type]\n",
        "        fp_data = false_positives_df[false_positives_df['error_type'] == error_type]\n",
        "        \n",
        "        # Calculate aggregated values\n",
        "        total_caught = (~error_data['missed']).sum()\n",
        "        total_missed = error_data['missed'].sum()\n",
        "        total_fp = fp_data['count'].sum()\n",
        "        \n",
        "        # Add traces for aggregated view\n",
        "        total_trace_idx = len(fig.data)\n",
        "        fig.add_trace(\n",
        "            go.Bar(\n",
        "                x=['All Users'],\n",
        "                y=[total_caught],\n",
        "                name='Caught' if i == 1 else None,\n",
        "                marker_color=colors['caught'],\n",
        "                showlegend=i == 1,\n",
        "                legendgroup='caught',\n",
        "                hovertemplate='Caught: %{y}<br>Error Type: ' + error_type + '<extra></extra>',\n",
        "            ),\n",
        "            row=1, col=i\n",
        "        )\n",
        "        total_traces.append(len(fig.data) - 1)\n",
        "        \n",
        "        fig.add_trace(\n",
        "            go.Bar(\n",
        "                x=['All Users'],\n",
        "                y=[total_missed],\n",
        "                name='Missed' if i == 1 else None,\n",
        "                marker_color=colors['missed'],\n",
        "                showlegend=i == 1,\n",
        "                legendgroup='missed',\n",
        "                hovertemplate='Missed: %{y}<br>Error Type: ' + error_type + '<extra></extra>',\n",
        "            ),\n",
        "            row=1, col=i\n",
        "        )\n",
        "        total_traces.append(len(fig.data) - 1)\n",
        "        \n",
        "        fig.add_trace(\n",
        "            go.Bar(\n",
        "                x=['All Users'],\n",
        "                y=[total_fp],\n",
        "                name='False Positives' if i == 1 else None,\n",
        "                marker_color=colors['false_positives'],\n",
        "                showlegend=i == 1,\n",
        "                legendgroup='false_positives',\n",
        "                hovertemplate='False Positives: %{y}<br>Error Type: ' + error_type + '<extra></extra>',\n",
        "            ),\n",
        "            row=1, col=i\n",
        "        )\n",
        "        total_traces.append(len(fig.data) - 1)\n",
        "        \n",
        "        # Add individual user traces (initially hidden)\n",
        "        for user_id in users:\n",
        "            user_data = error_data[error_data['user_id'] == user_id]\n",
        "            user_fp = fp_data[fp_data['user_id'] == user_id]\n",
        "            \n",
        "            # Calculate values\n",
        "            caught = (~user_data['missed']).sum()\n",
        "            missed = user_data['missed'].sum()\n",
        "            fp_count = user_fp['count'].iloc[0] if not user_fp.empty else 0\n",
        "            \n",
        "            trace_idx = len(fig.data)\n",
        "            fig.add_trace(\n",
        "                go.Bar(\n",
        "                    x=[f'User {user_id}'],\n",
        "                    y=[caught],\n",
        "                    name='Caught',\n",
        "                    marker_color=colors['caught'],\n",
        "                    showlegend=False,\n",
        "                    visible=False,\n",
        "                    legendgroup='caught',\n",
        "                    hovertemplate=f'User {user_id}<br>Caught: %{{y}}<extra></extra>',\n",
        "                ),\n",
        "                row=1, col=i\n",
        "            )\n",
        "            user_traces.append(len(fig.data) - 1)\n",
        "            \n",
        "            fig.add_trace(\n",
        "                go.Bar(\n",
        "                    x=[f'User {user_id}'],\n",
        "                    y=[missed],\n",
        "                    name='Missed',\n",
        "                    marker_color=colors['missed'],\n",
        "                    showlegend=False,\n",
        "                    visible=False,\n",
        "                    legendgroup='missed',\n",
        "                    hovertemplate=f'User {user_id}<br>Missed: %{{y}}<extra></extra>',\n",
        "                ),\n",
        "                row=1, col=i\n",
        "            )\n",
        "            user_traces.append(len(fig.data) - 1)\n",
        "            \n",
        "            fig.add_trace(\n",
        "                go.Bar(\n",
        "                    x=[f'User {user_id}'],\n",
        "                    y=[fp_count],\n",
        "                    name='False Positives',\n",
        "                    marker_color=colors['false_positives'],\n",
        "                    showlegend=False,\n",
        "                    visible=False,\n",
        "                    legendgroup='false_positives',\n",
        "                    hovertemplate=f'User {user_id}<br>False Positives: %{{y}}<extra></extra>',\n",
        "                ),\n",
        "                row=1, col=i\n",
        "            )\n",
        "            user_traces.append(len(fig.data) - 1)\n",
        "\n",
        "    # Add buttons for user selection\n",
        "    buttons = [\n",
        "        dict(\n",
        "            args=[{\n",
        "                'visible': [i in total_traces for i in range(len(fig.data))]\n",
        "            }],\n",
        "            label=\"All Users\",\n",
        "            method=\"restyle\"\n",
        "        )\n",
        "    ]\n",
        "    \n",
        "    # Add button for each user\n",
        "    for idx, user_id in enumerate(users):\n",
        "        user_visibility = []\n",
        "        for i in range(len(fig.data)):\n",
        "            subplot_idx = i // (3 * (len(users) + 1))\n",
        "            is_user_trace = (i - (subplot_idx * 3 * (len(users) + 1)) - 3) // 3 == idx\n",
        "            user_visibility.append(is_user_trace)\n",
        "        \n",
        "        buttons.append(dict(\n",
        "            args=[{'visible': user_visibility}],\n",
        "            label=f\"User {user_id}\",\n",
        "            method=\"restyle\"\n",
        "        ))\n",
        "\n",
        "    # Update layout with all settings\n",
        "    fig.update_layout(\n",
        "        barmode='stack',\n",
        "        title_text=f\"{type.capitalize()} Mode: Error Distribution by Type\",\n",
        "        height=500,\n",
        "        width=1000,\n",
        "        showlegend=True,\n",
        "        legend_title_text=\"Error Categories\",\n",
        "        hovermode='x unified',\n",
        "        margin=dict(l=50, r=120, t=130, b=50),\n",
        "        updatemenus=[dict(\n",
        "            buttons=buttons,\n",
        "            direction=\"down\",\n",
        "            showactive=True,\n",
        "            x=1.2,\n",
        "            xanchor=\"right\",\n",
        "            y=1.1,\n",
        "            yanchor=\"bottom\",\n",
        "            bgcolor='white',\n",
        "            bordercolor='darkgray',\n",
        "            font=dict(size=12),\n",
        "            pad=dict(r=10, t=10)\n",
        "        )],\n",
        "        annotations=[\n",
        "            dict(\n",
        "                text=title,\n",
        "                x=x,\n",
        "                y=1.025,\n",
        "                xref=\"paper\",\n",
        "                yref=\"paper\",\n",
        "                showarrow=False,\n",
        "                font=dict(size=14)\n",
        "            )\n",
        "            for title, x in zip(error_types, [0.13, 0.5, 0.87])\n",
        "        ]\n",
        "    )\n",
        "\n",
        "    # Update axes labels\n",
        "    fig.update_yaxes(title_text=\"Count\", row=1, col=1)\n",
        "    \n",
        "    return fig\n",
        "\n",
        "def create_heatmap(error_df, type):\n",
        "    \"\"\"\n",
        "    Create Plotly heatmap for average error times with YlOrRd color scale and zero minimum.\n",
        "    Uses zero values only when no non-zero values exist for a particular \n",
        "    instance/error type combination.\n",
        "    \"\"\"\n",
        "    all_data_matrix = pd.pivot_table(\n",
        "        error_df,\n",
        "        values='time',\n",
        "        index='instance',\n",
        "        columns='error_type',\n",
        "        aggfunc=lambda x: list(x)\n",
        "    )\n",
        "    \n",
        "    # Create matrix for final values\n",
        "    time_matrix = pd.DataFrame(\n",
        "        index=all_data_matrix.index,\n",
        "        columns=all_data_matrix.columns,\n",
        "        dtype=float\n",
        "    )\n",
        "    \n",
        "    # Fill in averages, using non-zero values when available, zero otherwise\n",
        "    for idx in all_data_matrix.index:\n",
        "        for col in all_data_matrix.columns:\n",
        "            values = all_data_matrix.loc[idx, col]\n",
        "            non_zero_values = [v for v in values if v > 0]\n",
        "            if non_zero_values:\n",
        "                time_matrix.loc[idx, col] = np.mean(non_zero_values)\n",
        "            else:\n",
        "                # If only zeros exist for this cell, use 0\n",
        "                time_matrix.loc[idx, col] = 0\n",
        "    \n",
        "    # print(f\"\\n{type} Mode - Time Matrix Statistics:\")\n",
        "    # print(f\"Min value: {time_matrix.values.min()}\")\n",
        "    # print(f\"Max value: {time_matrix.values.max()}\")\n",
        "    \n",
        "    hover_text = np.empty(time_matrix.shape, dtype=object)\n",
        "    for i in range(time_matrix.shape[0]):\n",
        "        for j in range(time_matrix.shape[1]):\n",
        "            values = all_data_matrix.iloc[i, j]\n",
        "            non_zero_count = sum(1 for v in values if v > 0)\n",
        "            total_count = len(values)\n",
        "            if non_zero_count > 0:\n",
        "                hover_text[i, j] = f\"Instance: {time_matrix.index[i]}<br>\" \\\n",
        "                                 f\"Error Type: {time_matrix.columns[j]}<br>\" \\\n",
        "                                 f\"Avg Time: {time_matrix.iloc[i, j]:.2f}<br>\" \\\n",
        "                                 f\"(from {non_zero_count} non-zero values)\"\n",
        "            else:\n",
        "                hover_text[i, j] = f\"Instance: {time_matrix.index[i]}<br>\" \\\n",
        "                                 f\"Error Type: {time_matrix.columns[j]}<br>\" \\\n",
        "                                 f\"Time: 0 (all {total_count} values were zero)\"\n",
        "    \n",
        "    fig = go.Figure(data=go.Heatmap(\n",
        "        z=time_matrix.values,\n",
        "        x=time_matrix.columns,\n",
        "        y=time_matrix.index,\n",
        "        colorscale='YlOrRd',\n",
        "        showscale=True,\n",
        "        text=np.round(time_matrix.values, 2),\n",
        "        texttemplate='%{text}',\n",
        "        textfont={'size': 10},\n",
        "        hovertemplate='%{customdata}<extra></extra>',\n",
        "        customdata=hover_text,\n",
        "        zmin=0,  # Set minimum value to 0\n",
        "        zmid=time_matrix.values.max() / 2 if time_matrix.values.max() > 0 else 0.5,  # Set midpoint\n",
        "        zauto=False  # Disable automatic range\n",
        "    ))\n",
        "    \n",
        "    fig.update_layout(\n",
        "        title=f'{type.capitalize()} Mode: Average Error Resolution Time by Instance<br><sub>*Using non-zero values where available; zero values shown where no non-zero times exist</sub>',\n",
        "        xaxis_title='Error Type',\n",
        "        yaxis_title='Instance',\n",
        "        height=500,\n",
        "        coloraxis_colorbar_title='Time'\n",
        "    )\n",
        "\n",
        "    fig = go.Figure(data=go.Heatmap(\n",
        "        z=time_matrix.values,\n",
        "        x=time_matrix.columns,\n",
        "        y=time_matrix.index,\n",
        "        colorscale='YlOrRd',\n",
        "        showscale=True,\n",
        "        text=np.round(time_matrix.values, 2),\n",
        "        texttemplate='%{text}',\n",
        "        textfont={'size': 10},\n",
        "        hovertemplate='%{customdata}<extra></extra>',\n",
        "        customdata=hover_text,\n",
        "        zmin=0,\n",
        "        zmid=time_matrix.values.max() / 2 if time_matrix.values.max() > 0 else 0.5,\n",
        "        zauto=False\n",
        "    ))\n",
        "    \n",
        "    fig.update_layout(\n",
        "        title=f'{type.capitalize()} Mode: Average Error Resolution Time by Instance<br><sub>Using non-zero values where available; zero values shown where no non-zero times exist</sub>',\n",
        "        xaxis_title='Error Type',\n",
        "        yaxis_title='Instance',\n",
        "        height=500,\n",
        "        width=1000,  # Set explicit width\n",
        "        margin=dict(l=50, r=50, t=100, b=50)\n",
        "    )\n",
        "    \n",
        "    return fig\n",
        "\n",
        "\n",
        "def planned_plot():\n",
        "    error_df, planned_df, false_positives_df = process_json_files('*-planned.json')\n",
        "    \n",
        "    # Create and display interactive distribution plot\n",
        "    dist_fig = create_interactive_visualization(error_df, false_positives_df, 'planned')\n",
        "    dist_fig.show()\n",
        "    \n",
        "    # Create and display heatmap\n",
        "    heatmap_fig = create_heatmap(error_df, 'planned')\n",
        "    heatmap_fig.show()\n",
        "\n",
        "def reactive_plot():\n",
        "    error_df, reactive_df, false_positives_df = process_json_files('*-reactive.json')\n",
        "    \n",
        "    # Create and display interactive distribution plot\n",
        "    dist_fig = create_interactive_visualization(error_df, false_positives_df, 'reactive')\n",
        "    dist_fig.show()\n",
        "    \n",
        "    # Create and display heatmap\n",
        "    heatmap_fig = create_heatmap(error_df, 'reactive')\n",
        "    heatmap_fig.show()"
      ],
      "id": "96ca6429",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.panel-tabset}\n",
        "## Planned"
      ],
      "id": "cb1d4412"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "planned_plot()"
      ],
      "id": "6aaa70c2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Reactive"
      ],
      "id": "c197962a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "reactive_plot()"
      ],
      "id": "316ad923",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::"
      ],
      "id": "8aa8375b"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/home/killgore/.local/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}